package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales (Ejemplo)

//terminal Token PLUS;
terminal Token MINUS;
// ...
terminal Token MULT;
terminal Token GREATER;
terminal Token DISTINC;
terminal Token ASSIGN;
terminal Token ACCESS;
terminal Token LPAR;
terminal Token RPAR;
terminal Token COL;
terminal Token SEMI;
terminal Token COMMA;
terminal Token AND;
terminal Token BEGIN;
terminal Token BOOL;
terminal Token CONST;
terminal Token IF;
terminal Token ELSE;
terminal Token THEN;
terminal Token END;
terminal Token FALSE;
terminal Token TRUE;
terminal Token FUNCT;
terminal Token INT;
terminal Token LOOP;
terminal Token WHILE;
terminal Token IS;
terminal Token OUT;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token TYPE;
terminal Token PROCEDURE;
terminal Token STRTEXT;
terminal Token INTEGER;
terminal Token FULLINTEGER;
terminal Token IDENTIFIER;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
// ...
non terminal gramatica, vacio;
non terminal procedureFirma, procedureFin, bloqueProcedure, bloqueBegin;
non terminal constante, constanteTipo;
non terminal declararPrimitivo, tipoPrimitivo, tipoPrimitivoTipo;
non terminal tipoRecord, tipoRecordFirma, tipoRecordCuerpo, tipoRecordCampo, tipoRecordFin;

//non terminal declaraciones, sentencias;
//non terminal constante, tipoPrimitivo, tipoEstructurado, variable;
//non terminal funcion, procedimiento;
//non terminal firmaFunc, sentenciasFunc, declaracionesFunc, firmaProc, sentenciasProc, declaracionesProc;
//non terminal listaParam, listaParamVal, listaParamRef;
//non terminal expAritmetica, expLogica, expAcceso, usoSubprograma, asignacion, controlFlujo;
//non terminal ifThenElse, sentenciaIf, sentenciaElse, sentenciaWhile, sentenciaPutLine;

// Declaracion de relaciones de precedencia
//precedence left     PLUS,
precedence left       AND;
precedence left       GREATER, DISTINC;
precedence left       MINUS;
precedence left       MULT;
precedence left       LPAR, RPAR;

// ...

// Declaraci�n de reglas de produccion


start with program;

program ::=
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   		
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= gramatica;

// Reglas de la gramatica
gramatica         ::= procedureFirma bloqueProcedure BEGIN bloqueBegin procedureFin;
vacio             ::= ;

procedureFirma    ::= PROCEDURE IDENTIFIER LPAR RPAR IS;
procedureFin      ::= END IDENTIFIER SEMI;

bloqueProcedure   ::= constante         bloqueProcedure
                    | declararPrimitivo bloqueProcedure
                    | tipoRecord        bloqueProcedure
                    | vacio;
bloqueBegin       ::= vacio;

// Constantes
constante         ::= IDENTIFIER COL CONST ASSIGN constanteTipo SEMI;
constanteTipo     ::= TRUE | FALSE | INTEGER;

// Tipos primitivos
declararPrimitivo ::= tipoPrimitivo SEMI
                    | tipoPrimitivo ASSIGN
                    error{:syntaxErrorManager.syntaxError("Asignación no permitida.");:};
tipoPrimitivo     ::= IDENTIFIER COL tipoPrimitivoTipo
                    | IDENTIFIER COMMA tipoPrimitivo;
tipoPrimitivoTipo ::= INT | BOOL;

// Tipos estructurados
tipoRecord        ::= tipoRecordFirma tipoRecordCuerpo tipoRecordFin;
tipoRecordFirma   ::= TYPE IDENTIFIER IS RECORD;
tipoRecordFin     ::= END RECORD SEMI;
tipoRecordCuerpo  ::= tipoRecordCampo
                    | tipoRecordCampo tipoRecordCuerpo;
tipoRecordCampo   ::= declararPrimitivo
                    | IDENTIFIER COL IDENTIFIER SEMI;