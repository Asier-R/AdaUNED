package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales (Ejemplo)

//terminal Token PLUS;
terminal Token MINUS;
// ...
terminal Token MULT;
terminal Token GREATER;
terminal Token DISTINC;
terminal Token ASSIGN;
terminal Token ACCESS;
terminal Token LPAR;
terminal Token RPAR;
terminal Token COL;
terminal Token SEMI;
terminal Token COMMA;
terminal Token AND;
terminal Token BEGIN;
terminal Token BOOL;
terminal Token CONST;
terminal Token IF;
terminal Token ELSE;
terminal Token THEN;
terminal Token END;
terminal Token FALSE;
terminal Token TRUE;
terminal Token FUNCT;
terminal Token INT;
terminal Token LOOP;
terminal Token WHILE;
terminal Token IS;
terminal Token OUT;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token TYPE;
terminal Token PROCEDURE;
terminal Token STRTEXT;
terminal Token INTEGER;
terminal Token IDENTIFIER;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
// ...
non terminal gramatica, vacio, parametros, parametro, parametroTipo, invocacion, invocacionLista;
non terminal procedureFirma, fin, bloqueProcedure, bloqueCuerpo, bloqueBegin;
non terminal constante, constanteTipo;
non terminal declararPrimitivo, tipoPrimitivo, tipoPrimitivoTipo;
non terminal record, declararRecord, tipoRecord, tipoRecordFirma, tipoRecordCuerpo, tipoRecordCampo, tipoRecordFin;
non terminal funcion, funcionFirma, funcionBloque, funcionBegin, tipoRetorno, funcionRetorno;
non terminal procedimiento, procedimientoFirma, procedimientoBloque, procedimientoBegin;
non terminal expresion, expresionDeAcceso, expresionLogica, operadorLogico;
non terminal sentencia, asignacion, asignacionIzq, flujoIf,flujoIfThen, flujoIfElse, flujoIfFin, flujoWhile, flujoWhileFin, entradaSalida;

non terminal errorDeAsignacion, errorMalAsignacion, errorFuncionSinReturn, errorContieneReturn , errorParametroPutLine, errorDeSintaxis;

// Declaracion de relaciones de precedencia
//precedence left     PLUS,
precedence left       AND;
precedence left       GREATER;
precedence left       DISTINC;
precedence left       MINUS;
precedence left       MULT;
precedence left       LPAR, RPAR;

// ...

// Declaraci�n de reglas de produccion


start with program;

program ::=
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   		
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= gramatica;

// REGLAS DE LA GRAMATICA
// Reglas globales //
gramatica          ::= procedureFirma bloqueProcedure BEGIN bloqueBegin fin;
vacio              ::= ;

procedureFirma     ::= PROCEDURE IDENTIFIER LPAR RPAR IS;
fin                ::= END IDENTIFIER SEMI;

bloqueProcedure    ::= bloqueCuerpo bloqueProcedure | vacio;

bloqueCuerpo       ::= tipoRecord | declararPrimitivo | declararRecord | funcion | procedimiento | constante | errorDeSintaxis;

bloqueBegin        ::= sentencia bloqueBegin | vacio;
//....................................................//


// Parametros de funciones y procedimientos //
parametros         ::= parametro
                     | parametro SEMI parametros
                     | vacio;

parametro          ::= IDENTIFIER COL     parametroTipo
                     | IDENTIFIER COL OUT parametroTipo
                     | IDENTIFIER COMMA   parametro;

parametroTipo      ::= tipoPrimitivoTipo | IDENTIFIER;
//....................................................//


// Constantes //
constante          ::= IDENTIFIER COL CONST ASSIGN constanteTipo SEMI;

constanteTipo      ::= TRUE | FALSE | INTEGER;
//....................................................//


// Tipos primitivos //
declararPrimitivo  ::= tipoPrimitivo SEMI
                     | tipoPrimitivo ASSIGN errorDeAsignacion;

tipoPrimitivo      ::= IDENTIFIER COL tipoPrimitivoTipo
                     | IDENTIFIER COMMA tipoPrimitivo;

tipoPrimitivoTipo  ::= INT | BOOL;
//....................................................//


// Tipos estructurados //
declararRecord     ::= record SEMI
                     | record ASSIGN errorDeAsignacion;

record             ::= IDENTIFIER COL IDENTIFIER
                     | IDENTIFIER COMMA record;

tipoRecord         ::= tipoRecordFirma tipoRecordCuerpo tipoRecordFin;
tipoRecordFirma    ::= TYPE IDENTIFIER IS RECORD;
tipoRecordFin      ::= END RECORD SEMI;
tipoRecordCuerpo   ::= tipoRecordCampo | tipoRecordCampo tipoRecordCuerpo;
tipoRecordCampo    ::= declararPrimitivo | declararRecord;
//....................................................//


// Funciones //
funcion            ::= funcionFirma funcionBloque BEGIN funcionBegin fin;

funcionFirma       ::= FUNCT IDENTIFIER LPAR parametros RPAR RETURN tipoRetorno IS;
funcionBloque      ::= bloqueCuerpo funcionBloque | vacio;
funcionBegin       ::= bloqueBegin funcionRetorno | bloqueBegin errorFuncionSinReturn;
funcionRetorno     ::= RETURN expresion SEMI;

tipoRetorno        ::= INT | BOOL | IDENTIFIER;
//....................................................//


// Procedimientos //
procedimiento      ::= procedimientoFirma procedimientoBloque BEGIN procedimientoBegin fin;

procedimientoFirma ::= PROCEDURE IDENTIFIER LPAR parametros RPAR IS;
procedimientoBloque::= bloqueCuerpo procedimientoBloque | vacio;

procedimientoBegin ::= bloqueBegin | bloqueBegin RETURN errorContieneReturn;
//....................................................//


// Expresiones //
expresion          ::= LPAR expresion RPAR
                     | expresion MINUS expresion
                     | expresion MULT expresion
                     | expresionLogica
                     | INTEGER;

expresionLogica    ::= LPAR expresionLogica RPAR
                     | expresion operadorLogico expresion
                     | invocacion
                     | expresionDeAcceso
                     | TRUE
                     | FALSE;

operadorLogico     ::= GREATER | DISTINC | AND;

expresionDeAcceso  ::= IDENTIFIER ACCESS expresionDeAcceso | IDENTIFIER;

invocacion         ::= IDENTIFIER LPAR invocacionLista RPAR;
invocacionLista    ::= expresion | expresion COMMA invocacionLista | vacio;
//....................................................//


// Sentencias //
sentencia          ::= asignacion | flujoIf | flujoWhile | entradaSalida | invocacion SEMI;

asignacion         ::= asignacionIzq ASSIGN expresion SEMI;
asignacionIzq      ::= expresionDeAcceso | expresion errorMalAsignacion;

flujoIf            ::= flujoIfThen flujoIfFin | flujoIfThen flujoIfElse flujoIfFin;
flujoIfThen        ::= IF expresionLogica THEN bloqueBegin;
flujoIfElse        ::= ELSE bloqueBegin;
flujoIfFin         ::= END IF SEMI;

flujoWhile         ::= WHILE expresionLogica LOOP bloqueBegin flujoWhileFin;
flujoWhileFin      ::= END LOOP SEMI;

entradaSalida      ::= PUTLINE LPAR STRTEXT   RPAR SEMI
                     | PUTLINE LPAR expresion RPAR SEMI
                     | PUTLINE LPAR expresion COMMA errorParametroPutLine;
//....................................................//


// Errores sintacticos
errorDeAsignacion     ::= error{:syntaxErrorManager.syntaxError("Error - Asignación no permitida");:};
errorMalAsignacion    ::= error{:syntaxErrorManager.syntaxError("Error - Asignación mal formada");:};
errorFuncionSinReturn ::= error{:syntaxErrorManager.syntaxError("Error - Error en la sentencia 'return'");:};
errorContieneReturn   ::= error{:syntaxErrorManager.syntaxError("Error - Procedimiento con sentencia 'return'");:};
errorParametroPutLine ::= error{:syntaxErrorManager.syntaxError("Error - Solo se admite un parámetro");:};
errorDeSintaxis       ::= IF error{:syntaxErrorManager.syntaxError("Error - Sentencia IF no permitida en bloque de declaración");:}
                        | WHILE error{:syntaxErrorManager.syntaxError("Error - Sentencia WHILE no permitida en bloque de declaración");:};
//....................................................//
